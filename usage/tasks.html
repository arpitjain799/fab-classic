
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Defining tasks &#8212; fab-classic  documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Troubleshooting" href="../troubleshooting.html" />
    <link rel="prev" title="SSH behavior" href="ssh.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="defining-tasks">
<h1>Defining tasks<a class="headerlink" href="#defining-tasks" title="Permalink to this headline">¶</a></h1>
<p>As of Fabric 1.1, there are two distinct methods you may use in order to define
which objects in your fabfile show up as tasks:</p>
<ul class="simple">
<li>The “new” method starting in 1.1 considers instances of <a class="reference internal" href="../api/core/tasks.html#fabric.tasks.Task" title="fabric.tasks.Task"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Task</span></code></a>
or its subclasses, and also descends into imported modules to allow building
nested namespaces.</li>
<li>The “classic” method from 1.0 and earlier considers all public callable
objects (functions, classes etc) and only considers the objects in the
fabfile itself with no recursing into imported module.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">These two methods are <strong>mutually exclusive</strong>: if Fabric finds <em>any</em>
new-style task objects in your fabfile or in modules it imports, it will
assume you’ve committed to this method of task declaration and won’t
consider any non-<a class="reference internal" href="../api/core/tasks.html#fabric.tasks.Task" title="fabric.tasks.Task"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Task</span></code></a> callables. If <em>no</em> new-style tasks
are found, it reverts to the classic behavior.</p>
</div>
<p>The rest of this document explores these two methods in detail.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">To see exactly what tasks in your fabfile may be executed via <code class="docutils literal notranslate"><span class="pre">fab</span></code>, use
<a class="reference internal" href="fab.html#cmdoption-l"><code class="xref std std-option docutils literal notranslate"><span class="pre">fab</span> <span class="pre">--list</span></code></a>.</p>
</div>
<div class="section" id="new-style-tasks">
<span id="id1"></span><h2>New-style tasks<a class="headerlink" href="#new-style-tasks" title="Permalink to this headline">¶</a></h2>
<p>Fabric 1.1 introduced the <a class="reference internal" href="../api/core/tasks.html#fabric.tasks.Task" title="fabric.tasks.Task"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Task</span></code></a> class to facilitate new features
and enable some programming best practices, specifically:</p>
<ul class="simple">
<li><strong>Object-oriented tasks</strong>. Inheritance and all that comes with it can make
for much more sensible code reuse than passing around simple function
objects.  The classic style of task declaration didn’t entirely rule this
out, but it also didn’t make it terribly easy.</li>
<li><strong>Namespaces</strong>. Having an explicit method of declaring tasks makes it easier
to set up recursive namespaces without e.g. polluting your task list with the
contents of Python’s <code class="docutils literal notranslate"><span class="pre">os</span></code> module (which would show up as valid “tasks”
under the classic methodology.)</li>
</ul>
<p>With the introduction of <a class="reference internal" href="../api/core/tasks.html#fabric.tasks.Task" title="fabric.tasks.Task"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Task</span></code></a>, there are two ways to set up new
tasks:</p>
<ul class="simple">
<li>Decorate a regular module level function with <a class="reference internal" href="../api/core/decorators.html#fabric.decorators.task" title="fabric.decorators.task"><code class="xref py py-obj docutils literal notranslate"><span class="pre">&#64;task</span></code></a>, which transparently wraps the function in a
<a class="reference internal" href="../api/core/tasks.html#fabric.tasks.Task" title="fabric.tasks.Task"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Task</span></code></a> subclass.  The function name will be used as the task
name when invoking.</li>
<li>Subclass <a class="reference internal" href="../api/core/tasks.html#fabric.tasks.Task" title="fabric.tasks.Task"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Task</span></code></a> (<a class="reference internal" href="../api/core/tasks.html#fabric.tasks.Task" title="fabric.tasks.Task"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Task</span></code></a> itself is intended to be
abstract), define a <code class="docutils literal notranslate"><span class="pre">run</span></code> method, and instantiate your subclass at module
level. Instances’ <code class="docutils literal notranslate"><span class="pre">name</span></code> attributes are used as the task name; if omitted
the instance’s variable name will be used instead.</li>
</ul>
<p>Use of new-style tasks also allows you to set up <a class="reference internal" href="#namespaces"><span class="std std-ref">namespaces</span></a>.</p>
<div class="section" id="the-task-decorator">
<span id="task-decorator"></span><h3>The <code class="docutils literal notranslate"><span class="pre">&#64;task</span></code> decorator<a class="headerlink" href="#the-task-decorator" title="Permalink to this headline">¶</a></h3>
<p>The quickest way to make use of new-style task features is to wrap basic task functions with <a class="reference internal" href="../api/core/decorators.html#fabric.decorators.task" title="fabric.decorators.task"><code class="xref py py-obj docutils literal notranslate"><span class="pre">&#64;task</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">fabric.api</span> <span class="kn">import</span> <span class="n">task</span><span class="p">,</span> <span class="n">run</span>

<span class="nd">@task</span>
<span class="k">def</span> <span class="nf">mytask</span><span class="p">():</span>
    <span class="n">run</span><span class="p">(</span><span class="s2">&quot;a command&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>When this decorator is used, it signals to Fabric that <em>only</em> functions wrapped in the decorator are to be loaded up as valid tasks. (When not present, <a class="reference internal" href="#classic-tasks"><span class="std std-ref">classic-style task</span></a> behavior kicks in.)</p>
<div class="section" id="arguments">
<span id="task-decorator-arguments"></span><h4>Arguments<a class="headerlink" href="#arguments" title="Permalink to this headline">¶</a></h4>
<p><a class="reference internal" href="../api/core/decorators.html#fabric.decorators.task" title="fabric.decorators.task"><code class="xref py py-obj docutils literal notranslate"><span class="pre">&#64;task</span></code></a> may also be called with arguments to
customize its behavior. Any arguments not documented below are passed into the
constructor of the <code class="docutils literal notranslate"><span class="pre">task_class</span></code> being used, with the function itself as the
first argument (see <a class="reference internal" href="#task-decorator-and-classes"><span class="std std-ref">Using custom subclasses with &#64;task</span></a> for details.)</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">task_class</span></code>: The <a class="reference internal" href="../api/core/tasks.html#fabric.tasks.Task" title="fabric.tasks.Task"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Task</span></code></a> subclass used to wrap the decorated
function. Defaults to <a class="reference internal" href="../api/core/tasks.html#fabric.tasks.WrappedCallableTask" title="fabric.tasks.WrappedCallableTask"><code class="xref py py-obj docutils literal notranslate"><span class="pre">WrappedCallableTask</span></code></a>.</li>
<li><code class="docutils literal notranslate"><span class="pre">aliases</span></code>: An iterable of string names which will be used as aliases for
the wrapped function. See <a class="reference internal" href="#task-aliases"><span class="std std-ref">Aliases</span></a> for details.</li>
<li><code class="docutils literal notranslate"><span class="pre">alias</span></code>: Like <code class="docutils literal notranslate"><span class="pre">aliases</span></code> but taking a single string argument instead of an
iterable. If both <code class="docutils literal notranslate"><span class="pre">alias</span></code> and <code class="docutils literal notranslate"><span class="pre">aliases</span></code> are specified, <code class="docutils literal notranslate"><span class="pre">aliases</span></code> will
take precedence.</li>
<li><code class="docutils literal notranslate"><span class="pre">default</span></code>: A boolean value determining whether the decorated task also
stands in for its containing module as a task name. See <a class="reference internal" href="#default-tasks"><span class="std std-ref">Default tasks</span></a>.</li>
<li><code class="docutils literal notranslate"><span class="pre">name</span></code>: A string setting the name this task appears as to the command-line
interface. Useful for task names that would otherwise shadow Python builtins
(which is technically legal but frowned upon and bug-prone.)</li>
</ul>
</div>
<div class="section" id="aliases">
<span id="task-aliases"></span><h4>Aliases<a class="headerlink" href="#aliases" title="Permalink to this headline">¶</a></h4>
<p>Here’s a quick example of using the <code class="docutils literal notranslate"><span class="pre">alias</span></code> keyword argument to facilitate
use of both a longer human-readable task name, and a shorter name which is
quicker to type:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">fabric.api</span> <span class="kn">import</span> <span class="n">task</span>

<span class="nd">@task</span><span class="p">(</span><span class="n">alias</span><span class="o">=</span><span class="s1">&#39;dwm&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">deploy_with_migrations</span><span class="p">():</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>Calling <a class="reference internal" href="fab.html#cmdoption-l"><code class="xref std std-option docutils literal notranslate"><span class="pre">--list</span></code></a> on this fabfile would show both the original
<code class="docutils literal notranslate"><span class="pre">deploy_with_migrations</span></code> and its alias <code class="docutils literal notranslate"><span class="pre">dwm</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ fab --list
Available commands:

    deploy_with_migrations
    dwm
</pre></div>
</div>
<p>When more than one alias for the same function is needed, simply swap in the
<code class="docutils literal notranslate"><span class="pre">aliases</span></code> kwarg, which takes an iterable of strings instead of a single
string.</p>
</div>
<div class="section" id="default-tasks">
<span id="id2"></span><h4>Default tasks<a class="headerlink" href="#default-tasks" title="Permalink to this headline">¶</a></h4>
<p>In a similar manner to <a class="reference internal" href="#task-aliases"><span class="std std-ref">aliases</span></a>, it’s sometimes useful to
designate a given task within a module as the “default” task, which may be
called by referencing <em>just</em> the module name. This can save typing and/or
allow for neater organization when there’s a single “main” task and a number
of related tasks or subroutines.</p>
<p>For example, a <code class="docutils literal notranslate"><span class="pre">deploy</span></code> submodule might contain tasks for provisioning new
servers, pushing code, migrating databases, and so forth – but it’d be very
convenient to highlight a task as the default “just deploy” action. Such a
<code class="docutils literal notranslate"><span class="pre">deploy.py</span></code> module might look like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">fabric.api</span> <span class="kn">import</span> <span class="n">task</span>

<span class="nd">@task</span>
<span class="k">def</span> <span class="nf">migrate</span><span class="p">():</span>
    <span class="k">pass</span>

<span class="nd">@task</span>
<span class="k">def</span> <span class="nf">push</span><span class="p">():</span>
    <span class="k">pass</span>

<span class="nd">@task</span>
<span class="k">def</span> <span class="nf">provision</span><span class="p">():</span>
    <span class="k">pass</span>

<span class="nd">@task</span>
<span class="k">def</span> <span class="nf">full_deploy</span><span class="p">():</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">provisioned</span><span class="p">:</span>
        <span class="n">provision</span><span class="p">()</span>
    <span class="n">push</span><span class="p">()</span>
    <span class="n">migrate</span><span class="p">()</span>
</pre></div>
</div>
<p>With the following task list (assuming a simple top level <code class="docutils literal notranslate"><span class="pre">fabfile.py</span></code> that just imports <code class="docutils literal notranslate"><span class="pre">deploy</span></code>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ fab --list
Available commands:

    deploy.full_deploy
    deploy.migrate
    deploy.provision
    deploy.push
</pre></div>
</div>
<p>Calling <code class="docutils literal notranslate"><span class="pre">deploy.full_deploy</span></code> on every deploy could get kind of old, or somebody new to the team might not be sure if that’s really the right task to run.</p>
<p>Using the <code class="docutils literal notranslate"><span class="pre">default</span></code> kwarg to <a class="reference internal" href="../api/core/decorators.html#fabric.decorators.task" title="fabric.decorators.task"><code class="xref py py-obj docutils literal notranslate"><span class="pre">&#64;task</span></code></a>, we can tag
e.g. <code class="docutils literal notranslate"><span class="pre">full_deploy</span></code> as the default task:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@task</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">full_deploy</span><span class="p">():</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>Doing so updates the task list like so:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ fab --list
Available commands:

    deploy
    deploy.full_deploy
    deploy.migrate
    deploy.provision
    deploy.push
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">full_deploy</span></code> still exists as its own explicit task – but now
<code class="docutils literal notranslate"><span class="pre">deploy</span></code> shows up as a sort of top level alias for <code class="docutils literal notranslate"><span class="pre">full_deploy</span></code>.</p>
<p>If multiple tasks within a module have <code class="docutils literal notranslate"><span class="pre">default=True</span></code> set, the last one to
be loaded (typically the one lowest down in the file) will take precedence.</p>
</div>
<div class="section" id="top-level-default-tasks">
<h4>Top-level default tasks<a class="headerlink" href="#top-level-default-tasks" title="Permalink to this headline">¶</a></h4>
<p>Using <code class="docutils literal notranslate"><span class="pre">&#64;task(default=True)</span></code> in the top level fabfile will cause the denoted
task to execute when a user invokes <code class="docutils literal notranslate"><span class="pre">fab</span></code> without any task names (similar to
e.g. <code class="docutils literal notranslate"><span class="pre">make</span></code>.) When using this shortcut, it is not possible to specify
arguments to the task itself – use a regular invocation of the task if this
is necessary.</p>
</div>
</div>
<div class="section" id="task-subclasses">
<span id="id3"></span><h3><code class="docutils literal notranslate"><span class="pre">Task</span></code> subclasses<a class="headerlink" href="#task-subclasses" title="Permalink to this headline">¶</a></h3>
<p>If you’re used to <a class="reference internal" href="#classic-tasks"><span class="std std-ref">classic-style tasks</span></a>, an easy way to
think about <a class="reference internal" href="../api/core/tasks.html#fabric.tasks.Task" title="fabric.tasks.Task"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Task</span></code></a> subclasses is that their <code class="docutils literal notranslate"><span class="pre">run</span></code> method is
directly equivalent to a classic task; its arguments are the task arguments
(other than <code class="docutils literal notranslate"><span class="pre">self</span></code>) and its body is what gets executed.</p>
<p>For example, this new-style task:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyTask</span><span class="p">(</span><span class="n">Task</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;deploy&quot;</span>
    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">environment</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="s2">&quot;whatever.com&quot;</span><span class="p">):</span>
        <span class="n">run</span><span class="p">(</span><span class="s2">&quot;git clone foo&quot;</span><span class="p">)</span>
        <span class="n">sudo</span><span class="p">(</span><span class="s2">&quot;service apache2 restart&quot;</span><span class="p">)</span>

<span class="n">instance</span> <span class="o">=</span> <span class="n">MyTask</span><span class="p">()</span>
</pre></div>
</div>
<p>is exactly equivalent to this function-based task:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@task</span>
<span class="k">def</span> <span class="nf">deploy</span><span class="p">(</span><span class="n">environment</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="s2">&quot;whatever.com&quot;</span><span class="p">):</span>
    <span class="n">run</span><span class="p">(</span><span class="s2">&quot;git clone foo&quot;</span><span class="p">)</span>
    <span class="n">sudo</span><span class="p">(</span><span class="s2">&quot;service apache2 restart&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Note how we had to instantiate an instance of our class; that’s simply normal
Python object-oriented programming at work. While it’s a small bit of
boilerplate right now – for example, Fabric doesn’t care about the name you
give the instantiation, only the instance’s <code class="docutils literal notranslate"><span class="pre">name</span></code> attribute – it’s well
worth the benefit of having the power of classes available.</p>
<p>We plan to extend the API in the future to make this experience a bit smoother.</p>
<div class="section" id="using-custom-subclasses-with-task">
<span id="task-decorator-and-classes"></span><h4>Using custom subclasses with <code class="docutils literal notranslate"><span class="pre">&#64;task</span></code><a class="headerlink" href="#using-custom-subclasses-with-task" title="Permalink to this headline">¶</a></h4>
<p>It’s possible to marry custom <a class="reference internal" href="../api/core/tasks.html#fabric.tasks.Task" title="fabric.tasks.Task"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Task</span></code></a> subclasses with <a class="reference internal" href="../api/core/decorators.html#fabric.decorators.task" title="fabric.decorators.task"><code class="xref py py-obj docutils literal notranslate"><span class="pre">&#64;task</span></code></a>. This may be useful in cases where your core
execution logic doesn’t do anything class/object-specific, but you want to
take advantage of class metaprogramming or similar techniques.</p>
<p>Specifically, any <a class="reference internal" href="../api/core/tasks.html#fabric.tasks.Task" title="fabric.tasks.Task"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Task</span></code></a> subclass which is designed to take in a
callable as its first constructor argument (as the built-in
<a class="reference internal" href="../api/core/tasks.html#fabric.tasks.WrappedCallableTask" title="fabric.tasks.WrappedCallableTask"><code class="xref py py-obj docutils literal notranslate"><span class="pre">WrappedCallableTask</span></code></a> does) may be specified as the
<code class="docutils literal notranslate"><span class="pre">task_class</span></code> argument to <a class="reference internal" href="../api/core/decorators.html#fabric.decorators.task" title="fabric.decorators.task"><code class="xref py py-obj docutils literal notranslate"><span class="pre">&#64;task</span></code></a>.</p>
<p>Fabric will automatically instantiate a copy of the given class, passing in
the wrapped function as the first argument. All other args/kwargs given to the
decorator (besides the “special” arguments documented in
<a class="reference internal" href="#task-decorator-arguments"><span class="std std-ref">Arguments</span></a>) are added afterwards.</p>
<p>Here’s a brief and somewhat contrived example to make this obvious:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">fabric.api</span> <span class="kn">import</span> <span class="n">task</span>
<span class="kn">from</span> <span class="nn">fabric.tasks</span> <span class="kn">import</span> <span class="n">Task</span>

<span class="k">class</span> <span class="nc">CustomTask</span><span class="p">(</span><span class="n">Task</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">myarg</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CustomTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">myarg</span> <span class="o">=</span> <span class="n">myarg</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="nd">@task</span><span class="p">(</span><span class="n">task_class</span><span class="o">=</span><span class="n">CustomTask</span><span class="p">,</span> <span class="n">myarg</span><span class="o">=</span><span class="s1">&#39;value&#39;</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="s1">&#39;at&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">actual_task</span><span class="p">():</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>When this fabfile is loaded, a copy of <code class="docutils literal notranslate"><span class="pre">CustomTask</span></code> is instantiated, effectively calling:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">task_obj</span> <span class="o">=</span> <span class="n">CustomTask</span><span class="p">(</span><span class="n">actual_task</span><span class="p">,</span> <span class="n">myarg</span><span class="o">=</span><span class="s1">&#39;value&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Note how the <code class="docutils literal notranslate"><span class="pre">alias</span></code> kwarg is stripped out by the decorator itself and never
reaches the class instantiation; this is identical in function to how
<a class="reference internal" href="fab.html#task-arguments"><span class="std std-ref">command-line task arguments</span></a> work.</p>
</div>
</div>
<div class="section" id="namespaces">
<span id="id4"></span><h3>Namespaces<a class="headerlink" href="#namespaces" title="Permalink to this headline">¶</a></h3>
<p>With <a class="reference internal" href="#classic-tasks"><span class="std std-ref">classic tasks</span></a>, fabfiles were limited to a single,
flat set of task names with no real way to organize them.  In Fabric 1.1 and
newer, if you declare tasks the new way (via <a class="reference internal" href="../api/core/decorators.html#fabric.decorators.task" title="fabric.decorators.task"><code class="xref py py-obj docutils literal notranslate"><span class="pre">&#64;task</span></code></a>
or your own <a class="reference internal" href="../api/core/tasks.html#fabric.tasks.Task" title="fabric.tasks.Task"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Task</span></code></a> subclass instances) you may take advantage
of <strong>namespacing</strong>:</p>
<ul class="simple">
<li>Any module objects imported into your fabfile will be recursed into, looking
for additional task objects.</li>
<li>Within submodules, you may control which objects are “exported” by using the
standard Python <code class="docutils literal notranslate"><span class="pre">__all__</span></code> module-level variable name (thought they should
still be valid new-style task objects.)</li>
<li>These tasks will be given new dotted-notation names based on the modules they
came from, similar to Python’s own import syntax.</li>
</ul>
<p>Let’s build up a fabfile package from simple to complex and see how this works.</p>
<div class="section" id="basic">
<h4>Basic<a class="headerlink" href="#basic" title="Permalink to this headline">¶</a></h4>
<p>We start with a single <code class="xref py py-obj docutils literal notranslate"><span class="pre">__init__.py</span></code> containing a few tasks (the Fabric API
import omitted for brevity):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@task</span>
<span class="k">def</span> <span class="nf">deploy</span><span class="p">():</span>
    <span class="o">...</span>

<span class="nd">@task</span>
<span class="k">def</span> <span class="nf">compress</span><span class="p">():</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>The output of <code class="docutils literal notranslate"><span class="pre">fab</span> <span class="pre">--list</span></code> would look something like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">deploy</span>
<span class="n">compress</span>
</pre></div>
</div>
<p>There’s just one namespace here: the “root” or global namespace. Looks simple
now, but in a real-world fabfile with dozens of tasks, it can get difficult to
manage.</p>
</div>
<div class="section" id="importing-a-submodule">
<h4>Importing a submodule<a class="headerlink" href="#importing-a-submodule" title="Permalink to this headline">¶</a></h4>
<p>As mentioned above, Fabric will examine any imported module objects for tasks,
regardless of where that module exists on your Python import path.  For now we
just want to include our own, “nearby” tasks, so we’ll make a new submodule in
our package for dealing with, say, load balancers – <code class="docutils literal notranslate"><span class="pre">lb.py</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@task</span>
<span class="k">def</span> <span class="nf">add_backend</span><span class="p">():</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>And we’ll add this to the top of <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">lb</span>
</pre></div>
</div>
<p>Now <code class="docutils literal notranslate"><span class="pre">fab</span> <span class="pre">--list</span></code> shows us:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">deploy</span>
<span class="n">compress</span>
<span class="n">lb</span><span class="o">.</span><span class="n">add_backend</span>
</pre></div>
</div>
<p>Again, with only one task in its own submodule, it looks kind of silly, but the
benefits should be pretty obvious.</p>
</div>
<div class="section" id="going-deeper">
<h4>Going deeper<a class="headerlink" href="#going-deeper" title="Permalink to this headline">¶</a></h4>
<p>Namespacing isn’t limited to just one level. Let’s say we had a larger setup
and wanted a namespace for database related tasks, with additional
differentiation inside that. We make a sub-package named <code class="docutils literal notranslate"><span class="pre">db/</span></code> and inside it,
a <code class="docutils literal notranslate"><span class="pre">migrations.py</span></code> module:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@task</span>
<span class="k">def</span> <span class="nf">list</span><span class="p">():</span>
    <span class="o">...</span>

<span class="nd">@task</span>
<span class="k">def</span> <span class="nf">run</span><span class="p">():</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>We need to make sure that this module is visible to anybody importing <code class="docutils literal notranslate"><span class="pre">db</span></code>,
so we add it to the sub-package’s <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">migrations</span>
</pre></div>
</div>
<p>As a final step, we import the sub-package into our root-level <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code>,
so now its first few lines look like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">lb</span>
<span class="kn">import</span> <span class="nn">db</span>
</pre></div>
</div>
<p>After all that, our file tree looks like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>.
├── __init__.py
├── db
│   ├── __init__.py
│   └── migrations.py
└── lb.py
</pre></div>
</div>
<p>and <code class="docutils literal notranslate"><span class="pre">fab</span> <span class="pre">--list</span></code> shows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">deploy</span>
<span class="n">compress</span>
<span class="n">lb</span><span class="o">.</span><span class="n">add_backend</span>
<span class="n">db</span><span class="o">.</span><span class="n">migrations</span><span class="o">.</span><span class="n">list</span>
<span class="n">db</span><span class="o">.</span><span class="n">migrations</span><span class="o">.</span><span class="n">run</span>
</pre></div>
</div>
<p>We could also have specified (or imported) tasks directly into
<code class="docutils literal notranslate"><span class="pre">db/__init__.py</span></code>, and they would show up as <code class="docutils literal notranslate"><span class="pre">db.&lt;whatever&gt;</span></code> as you might
expect.</p>
</div>
<div class="section" id="limiting-with-all">
<h4>Limiting with <code class="docutils literal notranslate"><span class="pre">__all__</span></code><a class="headerlink" href="#limiting-with-all" title="Permalink to this headline">¶</a></h4>
<p>You may limit what Fabric “sees” when it examines imported modules, by using
the Python convention of a module level <code class="docutils literal notranslate"><span class="pre">__all__</span></code> variable (a list of
variable names.) If we didn’t want the <code class="docutils literal notranslate"><span class="pre">db.migrations.run</span></code> task to show up by
default for some reason, we could add this to the top of <code class="docutils literal notranslate"><span class="pre">db/migrations.py</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;list&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>Note the lack of <code class="docutils literal notranslate"><span class="pre">'run'</span></code> there. You could, if needed, import <code class="docutils literal notranslate"><span class="pre">run</span></code> directly
into some other part of the hierarchy, but otherwise it’ll remain hidden.</p>
</div>
<div class="section" id="switching-it-up">
<h4>Switching it up<a class="headerlink" href="#switching-it-up" title="Permalink to this headline">¶</a></h4>
<p>We’ve been keeping our fabfile package neatly organized and importing it in a
straightforward manner, but the filesystem layout doesn’t actually matter here.
All Fabric’s loader cares about is the names the modules are given when they’re
imported.</p>
<p>For example, if we changed the top of our root <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> to look like
this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">db</span> <span class="k">as</span> <span class="nn">database</span>
</pre></div>
</div>
<p>Our task list would change thusly:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">deploy</span>
<span class="n">compress</span>
<span class="n">lb</span><span class="o">.</span><span class="n">add_backend</span>
<span class="n">database</span><span class="o">.</span><span class="n">migrations</span><span class="o">.</span><span class="n">list</span>
<span class="n">database</span><span class="o">.</span><span class="n">migrations</span><span class="o">.</span><span class="n">run</span>
</pre></div>
</div>
<p>This applies to any other import – you could import third party modules into
your own task hierarchy, or grab a deeply nested module and make it appear near
the top level.</p>
</div>
<div class="section" id="nested-list-output">
<h4>Nested list output<a class="headerlink" href="#nested-list-output" title="Permalink to this headline">¶</a></h4>
<p>As a final note, we’ve been using the default Fabric <a class="reference internal" href="fab.html#cmdoption-l"><code class="xref std std-option docutils literal notranslate"><span class="pre">--list</span></code></a>
output during this section – it makes it more obvious what the actual task
names are. However, you can get a more nested or tree-like view by passing
<code class="docutils literal notranslate"><span class="pre">nested</span></code> to the <a class="reference internal" href="fab.html#cmdoption-list-format"><code class="xref std std-option docutils literal notranslate"><span class="pre">--list-format</span></code></a> option:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ fab --list-format=nested --list
Available commands (remember to call as module.[...].task):

    deploy
    compress
    lb:
        add_backend
    database:
        migrations:
            list
            run
</pre></div>
</div>
<p>While it slightly obfuscates the “real” task names, this view provides a handy
way of noting the organization of tasks in large namespaces.</p>
</div>
</div>
</div>
<div class="section" id="classic-tasks">
<span id="id5"></span><h2>Classic tasks<a class="headerlink" href="#classic-tasks" title="Permalink to this headline">¶</a></h2>
<p>When no new-style <a class="reference internal" href="../api/core/tasks.html#fabric.tasks.Task" title="fabric.tasks.Task"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Task</span></code></a>-based tasks are found, Fabric will
consider any callable object found in your fabfile, <strong>except</strong> the following:</p>
<ul class="simple">
<li>Callables whose name starts with an underscore (<code class="docutils literal notranslate"><span class="pre">_</span></code>). In other words,
Python’s usual “private” convention holds true here.</li>
<li>Callables defined within Fabric itself. Fabric’s own functions such as
<a class="reference internal" href="../api/core/operations.html#fabric.operations.run" title="fabric.operations.run"><code class="xref py py-obj docutils literal notranslate"><span class="pre">run</span></code></a> and <a class="reference internal" href="../api/core/operations.html#fabric.operations.sudo" title="fabric.operations.sudo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sudo</span></code></a>  will not show up in
your task list.</li>
</ul>
<div class="section" id="imports">
<h3>Imports<a class="headerlink" href="#imports" title="Permalink to this headline">¶</a></h3>
<p>Python’s <code class="docutils literal notranslate"><span class="pre">import</span></code> statement effectively includes the imported objects in your
module’s namespace. Since Fabric’s fabfiles are just Python modules, this means
that imports are also considered as possible classic-style tasks, alongside
anything defined in the fabfile itself.</p>
<blockquote>
<div><div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This only applies to imported <em>callable objects</em> – not modules.
Imported modules only come into play if they contain <a class="reference internal" href="#new-style-tasks"><span class="std std-ref">new-style
tasks</span></a>, at which point this section no longer
applies.</p>
</div>
</div></blockquote>
<p>Because of this, we strongly recommend that you use the <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">module</span></code> form
of importing, followed by <code class="docutils literal notranslate"><span class="pre">module.callable()</span></code>, which will result in a cleaner
fabfile API than doing <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">callable</span></code>.</p>
<p>For example, here’s a sample fabfile which uses <code class="docutils literal notranslate"><span class="pre">urllib.urlopen</span></code> to get some
data out of a webservice:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">urllib</span> <span class="kn">import</span> <span class="n">urlopen</span>

<span class="kn">from</span> <span class="nn">fabric.api</span> <span class="kn">import</span> <span class="n">run</span>

<span class="k">def</span> <span class="nf">webservice_read</span><span class="p">():</span>
    <span class="n">objects</span> <span class="o">=</span> <span class="n">urlopen</span><span class="p">(</span><span class="s1">&#39;http://my/web/service/?foo=bar&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">objects</span><span class="p">)</span>
</pre></div>
</div>
<p>This looks simple enough, and will run without error. However, look what
happens if we run <a class="reference internal" href="fab.html#cmdoption-l"><code class="xref std std-option docutils literal notranslate"><span class="pre">fab</span> <span class="pre">--list</span></code></a> on this fabfile:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ fab --list
Available commands:

  webservice_read   List some directories.
  urlopen           urlopen(url [, data]) -&gt; open file-like object
</pre></div>
</div>
<p>Our fabfile of only one task is showing two “tasks”, which is bad enough, and
an unsuspecting user might accidentally try to call <code class="docutils literal notranslate"><span class="pre">fab</span> <span class="pre">urlopen</span></code>, which
probably won’t work very well. Imagine any real-world fabfile, which is likely
to be much more complex, and hopefully you can see how this could get messy
fast.</p>
<p>For reference, here’s the recommended way to do it:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">urllib</span>

<span class="kn">from</span> <span class="nn">fabric.api</span> <span class="kn">import</span> <span class="n">run</span>

<span class="k">def</span> <span class="nf">webservice_read</span><span class="p">():</span>
    <span class="n">objects</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s1">&#39;http://my/web/service/?foo=bar&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">objects</span><span class="p">)</span>
</pre></div>
</div>
<p>It’s a simple change, but it’ll make anyone using your fabfile a bit happier.</p>
</div>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../index.html">
    <img class="logo" src="../_static/logo.png" alt="Logo"/>
    
    <h1 class="logo logo-name">fab-classic</h1>
    
  </a>
</p>



<p class="blurb">Pythonic remote execution</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=ploxiln&repo=fab-classic&type=star&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





    

<p>
<a class="badge" href="https://travis-ci.org/ploxiln/fab-classic">
    <img
        alt="https://secure.travis-ci.org/ploxiln/fab-classic.svg?branch=master"
        src="https://secure.travis-ci.org/ploxiln/fab-classic.svg?branch=master"
    />
</a>
</p>


<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../installing.html">Installing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial.html">Overview and Tutorial</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="env.html">The environment dictionary, <code class="docutils literal notranslate"><span class="pre">env</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="execution.html">Execution model</a></li>
<li class="toctree-l1"><a class="reference internal" href="fab.html"><code class="docutils literal notranslate"><span class="pre">fab</span></code> options and arguments</a></li>
<li class="toctree-l1"><a class="reference internal" href="fabfiles.html">Fabfile construction and use</a></li>
<li class="toctree-l1"><a class="reference internal" href="interactivity.html">Interaction with remote programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="library.html">Library Use</a></li>
<li class="toctree-l1"><a class="reference internal" href="output_controls.html">Managing output</a></li>
<li class="toctree-l1"><a class="reference internal" href="parallel.html">Parallel execution</a></li>
<li class="toctree-l1"><a class="reference internal" href="ssh.html">SSH behavior</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Defining tasks</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#new-style-tasks">New-style tasks</a></li>
<li class="toctree-l2"><a class="reference internal" href="#classic-tasks">Classic tasks</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../troubleshooting.html">Troubleshooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq.html">Frequently Asked Questions (FAQ)</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../api/core/colors.html">Color output functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/core/context_managers.html">Context Managers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/core/decorators.html">Decorators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/core/docs.html">Documentation helpers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/core/network.html">Network</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/core/operations.html">Operations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/core/tasks.html">Tasks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/core/utils.html">Utils</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../api/contrib/console.html">Console Output Utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/contrib/django.html">Django Integration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/contrib/files.html">File and Directory Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/contrib/project.html">Project Tools</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../running_tests.html">Running Fabric’s Tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="../old_changelog.html">Old Changelog</a></li>
</ul>


<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;Fabric authors.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.5</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/usage/tasks.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>