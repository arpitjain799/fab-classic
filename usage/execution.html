
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Execution model &#8212; fab-classic  documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="fab options and arguments" href="fab.html" />
    <link rel="prev" title="The environment dictionary, env" href="env.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="execution-model">
<h1>Execution model<a class="headerlink" href="#execution-model" title="Permalink to this headline">¶</a></h1>
<p>If you’ve read the <a class="reference internal" href="../tutorial.html"><span class="doc">Overview and Tutorial</span></a>, you should already be familiar with how
Fabric operates in the base case (a single task on a single host.) However, in
many situations you’ll find yourself wanting to execute multiple tasks and/or
on multiple hosts. Perhaps you want to split a big task into smaller reusable
parts, or crawl a collection of servers looking for an old user to remove. Such
a scenario requires specific rules for when and how tasks are executed.</p>
<p>This document explores Fabric’s execution model, including the main execution
loop, how to define host lists, how connections are made, and so forth.</p>
<div class="section" id="execution-strategy">
<span id="id1"></span><h2>Execution strategy<a class="headerlink" href="#execution-strategy" title="Permalink to this headline">¶</a></h2>
<p>Fabric defaults to a single, serial execution method, though there is an
alternative parallel mode available as of Fabric 1.3 (see
<a class="reference internal" href="parallel.html"><span class="doc">Parallel execution</span></a>). This default behavior is as follows:</p>
<ul class="simple">
<li>A list of tasks is created. Currently this list is simply the arguments given
to <a class="reference internal" href="fab.html"><span class="doc">fab</span></a>, preserving the order given.</li>
<li>For each task, a task-specific host list is generated from various
sources (see <a class="reference internal" href="#host-lists"><span class="std std-ref">How host lists are constructed</span></a> below for details.)</li>
<li>The task list is walked through in order, and each task is run once per host
in its host list.</li>
<li>Tasks with no hosts in their host list are considered local-only, and will
always run once and only once.</li>
</ul>
<p>Thus, given the following fabfile:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">fabric.api</span> <span class="k">import</span> <span class="n">run</span><span class="p">,</span> <span class="n">env</span>

<span class="n">env</span><span class="o">.</span><span class="n">hosts</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;host1&#39;</span><span class="p">,</span> <span class="s1">&#39;host2&#39;</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">taskA</span><span class="p">():</span>
    <span class="n">run</span><span class="p">(</span><span class="s1">&#39;ls&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">taskB</span><span class="p">():</span>
    <span class="n">run</span><span class="p">(</span><span class="s1">&#39;whoami&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>and the following invocation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ fab taskA taskB
</pre></div>
</div>
<p>you will see that Fabric performs the following:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">taskA</span></code> executed on <code class="docutils literal notranslate"><span class="pre">host1</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">taskA</span></code> executed on <code class="docutils literal notranslate"><span class="pre">host2</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">taskB</span></code> executed on <code class="docutils literal notranslate"><span class="pre">host1</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">taskB</span></code> executed on <code class="docutils literal notranslate"><span class="pre">host2</span></code></li>
</ul>
<p>While this approach is simplistic, it allows for a straightforward composition
of task functions, and (unlike tools which push the multi-host functionality
down to the individual function calls) enables shell script-like logic where
you may introspect the output or return code of a given command and decide what
to do next.</p>
</div>
<div class="section" id="defining-tasks">
<h2>Defining tasks<a class="headerlink" href="#defining-tasks" title="Permalink to this headline">¶</a></h2>
<p>For details on what constitutes a Fabric task and how to organize them, please see <a class="reference internal" href="tasks.html"><span class="doc">Defining tasks</span></a>.</p>
</div>
<div class="section" id="defining-host-lists">
<h2>Defining host lists<a class="headerlink" href="#defining-host-lists" title="Permalink to this headline">¶</a></h2>
<p>Unless you’re using Fabric as a simple build system (which is possible, but not
the primary use-case) having tasks won’t do you any good without the ability to
specify remote hosts on which to execute them. There are a number of ways to do
so, with scopes varying from global to per-task, and it’s possible mix and
match as needed.</p>
<div class="section" id="hosts">
<span id="host-strings"></span><h3>Hosts<a class="headerlink" href="#hosts" title="Permalink to this headline">¶</a></h3>
<p>Hosts, in this context, refer to what are also called “host strings”: Python
strings specifying a username, hostname and port combination, in the form of
<code class="docutils literal notranslate"><span class="pre">username&#64;hostname:port</span></code>. User and/or port (and the associated <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> or
<code class="docutils literal notranslate"><span class="pre">:</span></code>) may be omitted, and will be filled by the executing user’s local
username, and/or port 22, respectively. Thus, <code class="docutils literal notranslate"><span class="pre">admin&#64;foo.com:222</span></code>,
<code class="docutils literal notranslate"><span class="pre">deploy&#64;website</span></code> and <code class="docutils literal notranslate"><span class="pre">nameserver1</span></code> could all be valid host strings.</p>
<p>IPv6 address notation is also supported, for example <code class="docutils literal notranslate"><span class="pre">::1</span></code>, <code class="docutils literal notranslate"><span class="pre">[::1]:1222</span></code>,
<code class="docutils literal notranslate"><span class="pre">user&#64;2001:db8::1</span></code> or <code class="docutils literal notranslate"><span class="pre">user&#64;[2001:db8::1]:1222</span></code>. Square brackets
are necessary only to separate the address from the port number. If no
port number is used, the brackets are optional. Also if host string is
specified via command-line argument, it may be necessary to escape
brackets in some shells.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The user/hostname split occurs at the last <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> found, so e.g. email
address usernames are valid and will be parsed correctly.</p>
</div>
<p>During execution, Fabric normalizes the host strings given and then stores each
part (username/hostname/port) in the environment dictionary, for both its use
and for tasks to reference if the need arises. See <a class="reference internal" href="env.html"><span class="doc">The environment dictionary, env</span></a> for details.</p>
</div>
<div class="section" id="roles">
<span id="execution-roles"></span><h3>Roles<a class="headerlink" href="#roles" title="Permalink to this headline">¶</a></h3>
<p>Host strings map to single hosts, but sometimes it’s useful to arrange hosts in
groups. Perhaps you have a number of Web servers behind a load balancer and
want to update all of them, or want to run a task on “all client servers”.
Roles provide a way of defining strings which correspond to lists of host
strings, and can then be specified instead of writing out the entire list every
time.</p>
<p>This mapping is defined as a dictionary, <code class="docutils literal notranslate"><span class="pre">env.roledefs</span></code>, which must be
modified by a fabfile in order to be used. A simple example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">fabric.api</span> <span class="k">import</span> <span class="n">env</span>

<span class="n">env</span><span class="o">.</span><span class="n">roledefs</span><span class="p">[</span><span class="s1">&#39;webservers&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;www1&#39;</span><span class="p">,</span> <span class="s1">&#39;www2&#39;</span><span class="p">,</span> <span class="s1">&#39;www3&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>Since <code class="docutils literal notranslate"><span class="pre">env.roledefs</span></code> is naturally empty by default, you may also opt to
re-assign to it without fear of losing any information (provided you aren’t
loading other fabfiles which also modify it, of course):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">fabric.api</span> <span class="k">import</span> <span class="n">env</span>

<span class="n">env</span><span class="o">.</span><span class="n">roledefs</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;web&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;www1&#39;</span><span class="p">,</span> <span class="s1">&#39;www2&#39;</span><span class="p">,</span> <span class="s1">&#39;www3&#39;</span><span class="p">],</span>
    <span class="s1">&#39;dns&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;ns1&#39;</span><span class="p">,</span> <span class="s1">&#39;ns2&#39;</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Role definitions are not necessarily configuration of hosts only, they can
also hold additional role specific settings of your choice. This is achieved
by defining the roles as dicts and host strings under a <code class="docutils literal notranslate"><span class="pre">hosts</span></code> key:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">fabric.api</span> <span class="k">import</span> <span class="n">env</span>

<span class="n">env</span><span class="o">.</span><span class="n">roledefs</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;web&#39;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s1">&#39;hosts&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;www1&#39;</span><span class="p">,</span> <span class="s1">&#39;www2&#39;</span><span class="p">,</span> <span class="s1">&#39;www3&#39;</span><span class="p">],</span>
        <span class="s1">&#39;foo&#39;</span><span class="p">:</span> <span class="s1">&#39;bar&#39;</span>
    <span class="p">},</span>
    <span class="s1">&#39;dns&#39;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s1">&#39;hosts&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;ns1&#39;</span><span class="p">,</span> <span class="s1">&#39;ns2&#39;</span><span class="p">],</span>
        <span class="s1">&#39;foo&#39;</span><span class="p">:</span> <span class="s1">&#39;baz&#39;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In addition to list/iterable object types, the values in <code class="docutils literal notranslate"><span class="pre">env.roledefs</span></code>
(or value of <code class="docutils literal notranslate"><span class="pre">hosts</span></code> key in dict style definition) may be callables, and will
thus be called when looked up when tasks are run instead of at module load
time. (For example, you could connect to remote servers to obtain role
definitions, and not worry about causing delays at fabfile load time when
calling e.g. <code class="docutils literal notranslate"><span class="pre">fab</span> <span class="pre">--list</span></code>.)</p>
<p>Use of roles is not required in any way – it’s simply a convenience in
situations where you have common groupings of servers.</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 0.9.2: </span>Added ability to use callables as <code class="docutils literal notranslate"><span class="pre">roledefs</span></code> values.</p>
</div>
</div>
<div class="section" id="how-host-lists-are-constructed">
<span id="host-lists"></span><h3>How host lists are constructed<a class="headerlink" href="#how-host-lists-are-constructed" title="Permalink to this headline">¶</a></h3>
<p>There are a number of ways to specify host lists, either globally or per-task,
and generally these methods override one another instead of merging together
(though this may change in future releases.) Each such method is typically
split into two parts, one for hosts and one for roles.</p>
<div class="section" id="globally-via-env">
<h4>Globally, via <code class="docutils literal notranslate"><span class="pre">env</span></code><a class="headerlink" href="#globally-via-env" title="Permalink to this headline">¶</a></h4>
<p>The most common method of setting hosts or roles is by modifying two key-value
pairs in the environment dictionary, <a class="reference internal" href="env.html"><span class="doc">env</span></a>: <code class="docutils literal notranslate"><span class="pre">hosts</span></code> and <code class="docutils literal notranslate"><span class="pre">roles</span></code>.
The value of these variables is checked at runtime, while constructing each
tasks’s host list.</p>
<p>Thus, they may be set at module level, which will take effect when the fabfile
is imported:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">fabric.api</span> <span class="k">import</span> <span class="n">env</span><span class="p">,</span> <span class="n">run</span>

<span class="n">env</span><span class="o">.</span><span class="n">hosts</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;host1&#39;</span><span class="p">,</span> <span class="s1">&#39;host2&#39;</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">mytask</span><span class="p">():</span>
    <span class="n">run</span><span class="p">(</span><span class="s1">&#39;ls /var/www&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Such a fabfile, run simply as <code class="docutils literal notranslate"><span class="pre">fab</span> <span class="pre">mytask</span></code>, will run <code class="docutils literal notranslate"><span class="pre">mytask</span></code> on <code class="docutils literal notranslate"><span class="pre">host1</span></code>
followed by <code class="docutils literal notranslate"><span class="pre">host2</span></code>.</p>
<p>Since the env vars are checked for <em>each</em> task, this means that if you have the
need, you can actually modify <code class="docutils literal notranslate"><span class="pre">env</span></code> in one task and it will affect all
following tasks:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">fabric.api</span> <span class="k">import</span> <span class="n">env</span><span class="p">,</span> <span class="n">run</span>

<span class="k">def</span> <span class="nf">set_hosts</span><span class="p">():</span>
    <span class="n">env</span><span class="o">.</span><span class="n">hosts</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;host1&#39;</span><span class="p">,</span> <span class="s1">&#39;host2&#39;</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">mytask</span><span class="p">():</span>
    <span class="n">run</span><span class="p">(</span><span class="s1">&#39;ls /var/www&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>When run as <code class="docutils literal notranslate"><span class="pre">fab</span> <span class="pre">set_hosts</span> <span class="pre">mytask</span></code>, <code class="docutils literal notranslate"><span class="pre">set_hosts</span></code> is a “local” task – its
own host list is empty – but <code class="docutils literal notranslate"><span class="pre">mytask</span></code> will again run on the two hosts given.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This technique used to be a common way of creating fake “roles”, but is
less necessary now that roles are fully implemented. It may still be useful
in some situations, however.</p>
</div>
<p>Alongside <code class="docutils literal notranslate"><span class="pre">env.hosts</span></code> is <code class="docutils literal notranslate"><span class="pre">env.roles</span></code> (not to be confused with
<code class="docutils literal notranslate"><span class="pre">env.roledefs</span></code>!) which, if given, will be taken as a list of role names to
look up in <code class="docutils literal notranslate"><span class="pre">env.roledefs</span></code>.</p>
</div>
<div class="section" id="globally-via-the-command-line">
<h4>Globally, via the command line<a class="headerlink" href="#globally-via-the-command-line" title="Permalink to this headline">¶</a></h4>
<p>In addition to modifying <code class="docutils literal notranslate"><span class="pre">env.hosts</span></code>, <code class="docutils literal notranslate"><span class="pre">env.roles</span></code>, and
<code class="docutils literal notranslate"><span class="pre">env.exclude_hosts</span></code> at the module level, you may define them by passing
comma-separated string arguments to the command-line switches
<a class="reference internal" href="fab.html#cmdoption-hosts"><code class="xref std std-option docutils literal notranslate"><span class="pre">--hosts/-H</span></code></a> and <a class="reference internal" href="fab.html#cmdoption-roles"><code class="xref std std-option docutils literal notranslate"><span class="pre">--roles/-R</span></code></a>, e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ fab -H host1,host2 mytask
</pre></div>
</div>
<p>Such an invocation is directly equivalent to <code class="docutils literal notranslate"><span class="pre">env.hosts</span> <span class="pre">=</span> <span class="pre">['host1',</span> <span class="pre">'host2']</span></code>
– the argument parser knows to look for these arguments and will modify
<code class="docutils literal notranslate"><span class="pre">env</span></code> at parse time.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It’s possible, and in fact common, to use these switches to set only a
single host or role. Fabric simply calls <code class="docutils literal notranslate"><span class="pre">string.split(',')</span></code> on the given
string, so a string with no commas turns into a single-item list.</p>
</div>
<p>It is important to know that these command-line switches are interpreted
<strong>before</strong> your fabfile is loaded: any reassignment to <code class="docutils literal notranslate"><span class="pre">env.hosts</span></code> or
<code class="docutils literal notranslate"><span class="pre">env.roles</span></code> in your fabfile will overwrite them.</p>
<p>If you wish to nondestructively merge the command-line hosts with your
fabfile-defined ones, make sure your fabfile uses <code class="docutils literal notranslate"><span class="pre">env.hosts.extend()</span></code>
instead:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">fabric.api</span> <span class="k">import</span> <span class="n">env</span><span class="p">,</span> <span class="n">run</span>

<span class="n">env</span><span class="o">.</span><span class="n">hosts</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s1">&#39;host3&#39;</span><span class="p">,</span> <span class="s1">&#39;host4&#39;</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">mytask</span><span class="p">():</span>
    <span class="n">run</span><span class="p">(</span><span class="s1">&#39;ls /var/www&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>When this fabfile is run as <code class="docutils literal notranslate"><span class="pre">fab</span> <span class="pre">-H</span> <span class="pre">host1,host2</span> <span class="pre">mytask</span></code>, <code class="docutils literal notranslate"><span class="pre">env.hosts</span></code> will
then contain <code class="docutils literal notranslate"><span class="pre">['host1',</span> <span class="pre">'host2',</span> <span class="pre">'host3',</span> <span class="pre">'host4']</span></code> at the time that
<code class="docutils literal notranslate"><span class="pre">mytask</span></code> is executed.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">env.hosts</span></code> is simply a Python list object – so you may use
<code class="docutils literal notranslate"><span class="pre">env.hosts.append()</span></code> or any other such method you wish.</p>
</div>
</div>
<div class="section" id="per-task-via-the-command-line">
<span id="hosts-per-task-cli"></span><h4>Per-task, via the command line<a class="headerlink" href="#per-task-via-the-command-line" title="Permalink to this headline">¶</a></h4>
<p>Globally setting host lists only works if you want all your tasks to run on the
same host list all the time. This isn’t always true, so Fabric provides a few
ways to be more granular and specify host lists which apply to a single task
only. The first of these uses task arguments.</p>
<p>As outlined in <a class="reference internal" href="fab.html"><span class="doc">fab options and arguments</span></a>, it’s possible to specify per-task arguments via a
special command-line syntax. In addition to naming actual arguments to your
task function, this may be used to set the <code class="docutils literal notranslate"><span class="pre">host</span></code>, <code class="docutils literal notranslate"><span class="pre">hosts</span></code>, <code class="docutils literal notranslate"><span class="pre">role</span></code> or
<code class="docutils literal notranslate"><span class="pre">roles</span></code> “arguments”, which are interpreted by Fabric when building host lists
(and removed from the arguments passed to the task itself.)</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Since commas are already used to separate task arguments from one another,
semicolons must be used in the <code class="docutils literal notranslate"><span class="pre">hosts</span></code> or <code class="docutils literal notranslate"><span class="pre">roles</span></code> arguments to
delineate individual host strings or role names. Furthermore, the argument
must be quoted to prevent your shell from interpreting the semicolons.</p>
</div>
<p>Take the below fabfile, which is the same one we’ve been using, but which
doesn’t define any host info at all:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">fabric.api</span> <span class="k">import</span> <span class="n">run</span>

<span class="k">def</span> <span class="nf">mytask</span><span class="p">():</span>
    <span class="n">run</span><span class="p">(</span><span class="s1">&#39;ls /var/www&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>To specify per-task hosts for <code class="docutils literal notranslate"><span class="pre">mytask</span></code>, execute it like so:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ fab mytask:hosts=&quot;host1;host2&quot;
</pre></div>
</div>
<p>This will override any other host list and ensure <code class="docutils literal notranslate"><span class="pre">mytask</span></code> always runs on
just those two hosts.</p>
</div>
<div class="section" id="per-task-via-decorators">
<h4>Per-task, via decorators<a class="headerlink" href="#per-task-via-decorators" title="Permalink to this headline">¶</a></h4>
<p>If a given task should always run on a predetermined host list, you may wish to
specify this in your fabfile itself. This can be done by decorating a task
function with the <a class="reference internal" href="../api/core/decorators.html#fabric.decorators.hosts" title="fabric.decorators.hosts"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hosts</span></code></a> or <a class="reference internal" href="../api/core/decorators.html#fabric.decorators.roles" title="fabric.decorators.roles"><code class="xref py py-obj docutils literal notranslate"><span class="pre">roles</span></code></a>
decorators. These decorators take a variable argument list, like so:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">fabric.api</span> <span class="k">import</span> <span class="n">hosts</span><span class="p">,</span> <span class="n">run</span>

<span class="nd">@hosts</span><span class="p">(</span><span class="s1">&#39;host1&#39;</span><span class="p">,</span> <span class="s1">&#39;host2&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">mytask</span><span class="p">():</span>
    <span class="n">run</span><span class="p">(</span><span class="s1">&#39;ls /var/www&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>They will also take an single iterable argument, e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">my_hosts</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;host1&#39;</span><span class="p">,</span> <span class="s1">&#39;host2&#39;</span><span class="p">)</span>
<span class="nd">@hosts</span><span class="p">(</span><span class="n">my_hosts</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">mytask</span><span class="p">():</span>
    <span class="c1"># ...</span>
</pre></div>
</div>
<p>When used, these decorators override any checks of <code class="docutils literal notranslate"><span class="pre">env</span></code> for that particular
task’s host list (though <code class="docutils literal notranslate"><span class="pre">env</span></code> is not modified in any way – it is simply
ignored.) Thus, even if the above fabfile had defined <code class="docutils literal notranslate"><span class="pre">env.hosts</span></code> or the call
to <a class="reference internal" href="fab.html"><span class="doc">fab</span></a> uses <a class="reference internal" href="fab.html#cmdoption-hosts"><code class="xref std std-option docutils literal notranslate"><span class="pre">--hosts/-H</span></code></a>, <code class="docutils literal notranslate"><span class="pre">mytask</span></code> would still run
on a host list of <code class="docutils literal notranslate"><span class="pre">['host1',</span> <span class="pre">'host2']</span></code>.</p>
<p>However, decorator host lists do <strong>not</strong> override per-task command-line
arguments, as given in the previous section.</p>
</div>
<div class="section" id="order-of-precedence">
<h4>Order of precedence<a class="headerlink" href="#order-of-precedence" title="Permalink to this headline">¶</a></h4>
<p>We’ve been pointing out which methods of setting host lists trump the others,
as we’ve gone along. However, to make things clearer, here’s a quick breakdown:</p>
<ul class="simple">
<li>Per-task, command-line host lists (<code class="docutils literal notranslate"><span class="pre">fab</span> <span class="pre">mytask:host=host1</span></code>) override
absolutely everything else.</li>
<li>Per-task, decorator-specified host lists (<code class="docutils literal notranslate"><span class="pre">&#64;hosts('host1')</span></code>) override the
<code class="docutils literal notranslate"><span class="pre">env</span></code> variables.</li>
<li>Globally specified host lists set in the fabfile (<code class="docutils literal notranslate"><span class="pre">env.hosts</span> <span class="pre">=</span> <span class="pre">['host1']</span></code>)
<em>can</em> override such lists set on the command-line, but only if you’re not
careful (or want them to.)</li>
<li>Globally specified host lists set on the command-line (<code class="docutils literal notranslate"><span class="pre">--hosts=host1</span></code>)
will initialize the <code class="docutils literal notranslate"><span class="pre">env</span></code> variables, but that’s it.</li>
</ul>
<p>This logic may change slightly in the future to be more consistent (e.g.
having <a class="reference internal" href="fab.html#cmdoption-hosts"><code class="xref std std-option docutils literal notranslate"><span class="pre">--hosts</span></code></a> somehow take precedence over <code class="docutils literal notranslate"><span class="pre">env.hosts</span></code> in the
same way that command-line per-task lists trump in-code ones) but only in a
backwards-incompatible release.</p>
</div>
</div>
<div class="section" id="combining-host-lists">
<span id="id2"></span><h3>Combining host lists<a class="headerlink" href="#combining-host-lists" title="Permalink to this headline">¶</a></h3>
<p>There is no “unionizing” of hosts between the various sources mentioned in
<a class="reference internal" href="#host-lists"><span class="std std-ref">How host lists are constructed</span></a>. If <code class="docutils literal notranslate"><span class="pre">env.hosts</span></code> is set to <code class="docutils literal notranslate"><span class="pre">['host1',</span> <span class="pre">'host2',</span> <span class="pre">'host3']</span></code>,
and a per-function (e.g.  via <a class="reference internal" href="../api/core/decorators.html#fabric.decorators.hosts" title="fabric.decorators.hosts"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hosts</span></code></a>) host list is set to
just <code class="docutils literal notranslate"><span class="pre">['host2',</span> <span class="pre">'host3']</span></code>, that function will <strong>not</strong> execute on <code class="docutils literal notranslate"><span class="pre">host1</span></code>,
because the per-task decorator host list takes precedence.</p>
<p>However, for each given source, if both roles <strong>and</strong> hosts are specified, they
will be merged together into a single host list. Take, for example, this
fabfile where both of the decorators are used:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">fabric.api</span> <span class="k">import</span> <span class="n">env</span><span class="p">,</span> <span class="n">hosts</span><span class="p">,</span> <span class="n">roles</span><span class="p">,</span> <span class="n">run</span>

<span class="n">env</span><span class="o">.</span><span class="n">roledefs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;role1&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">]}</span>

<span class="nd">@hosts</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="nd">@roles</span><span class="p">(</span><span class="s1">&#39;role1&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">mytask</span><span class="p">():</span>
    <span class="n">run</span><span class="p">(</span><span class="s1">&#39;ls /var/www&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Assuming no command-line hosts or roles are given when <code class="docutils literal notranslate"><span class="pre">mytask</span></code> is executed,
this fabfile will call <code class="docutils literal notranslate"><span class="pre">mytask</span></code> on a host list of <code class="docutils literal notranslate"><span class="pre">['a',</span> <span class="pre">'b',</span> <span class="pre">'c']</span></code> – the
union of <code class="docutils literal notranslate"><span class="pre">role1</span></code> and the contents of the <a class="reference internal" href="../api/core/decorators.html#fabric.decorators.hosts" title="fabric.decorators.hosts"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hosts</span></code></a> call.</p>
</div>
<div class="section" id="host-list-deduplication">
<span id="deduplication"></span><h3>Host list deduplication<a class="headerlink" href="#host-list-deduplication" title="Permalink to this headline">¶</a></h3>
<p>By default, to support <a class="reference internal" href="#combining-host-lists"><span class="std std-ref">Combining host lists</span></a>, Fabric deduplicates the
final host list so any given host string is only present once. However, this
prevents explicit/intentional running of a task multiple times on the same
target host, which is sometimes useful.</p>
<p>To turn off deduplication, set <a class="reference internal" href="env.html#dedupe-hosts"><span class="std std-ref">env.dedupe_hosts</span></a> to
<code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</div>
<div class="section" id="excluding-specific-hosts">
<span id="excluding-hosts"></span><h3>Excluding specific hosts<a class="headerlink" href="#excluding-specific-hosts" title="Permalink to this headline">¶</a></h3>
<p>At times, it is useful to exclude one or more specific hosts, e.g. to override
a few bad or otherwise undesirable hosts which are pulled in from a role or an
autogenerated host list.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">As of Fabric 1.4, you may wish to use <a class="reference internal" href="env.html#skip-bad-hosts"><span class="std std-ref">skip_bad_hosts</span></a> instead, which
automatically skips over any unreachable hosts.</p>
</div>
<p>Host exclusion may be accomplished globally with <a class="reference internal" href="fab.html#cmdoption-x"><code class="xref std std-option docutils literal notranslate"><span class="pre">--exclude-hosts/-x</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ fab -R myrole -x host2,host5 mytask
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">myrole</span></code> was defined as <code class="docutils literal notranslate"><span class="pre">['host1',</span> <span class="pre">'host2',</span> <span class="pre">...,</span> <span class="pre">'host15']</span></code>, the above
invocation would run with an effective host list of <code class="docutils literal notranslate"><span class="pre">['host1',</span> <span class="pre">'host3',</span>
<span class="pre">'host4',</span> <span class="pre">'host6',</span> <span class="pre">...,</span> <span class="pre">'host15']</span></code>.</p>
<blockquote>
<div><div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Using this option does not modify <code class="docutils literal notranslate"><span class="pre">env.hosts</span></code> – it only causes the
main execution loop to skip the requested hosts.</p>
</div>
</div></blockquote>
<p>Exclusions may be specified per-task by using an extra <code class="docutils literal notranslate"><span class="pre">exclude_hosts</span></code> kwarg,
which is implemented similarly to the abovementioned <code class="docutils literal notranslate"><span class="pre">hosts</span></code> and <code class="docutils literal notranslate"><span class="pre">roles</span></code>
per-task kwargs, in that it is stripped from the actual task invocation. This
example would have the same result as the global exclude above:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ fab mytask:roles=myrole,exclude_hosts=&quot;host2;host5&quot;
</pre></div>
</div>
<p>Note that the host list is semicolon-separated, just as with the <code class="docutils literal notranslate"><span class="pre">hosts</span></code>
per-task argument.</p>
<div class="section" id="combining-exclusions">
<h4>Combining exclusions<a class="headerlink" href="#combining-exclusions" title="Permalink to this headline">¶</a></h4>
<p>Host exclusion lists, like host lists themselves, are not merged together
across the different “levels” they can be declared in. For example, a global
<code class="docutils literal notranslate"><span class="pre">-x</span></code> option will not affect a per-task host list set with a decorator or
keyword argument, nor will per-task <code class="docutils literal notranslate"><span class="pre">exclude_hosts</span></code> keyword arguments affect
a global <code class="docutils literal notranslate"><span class="pre">-H</span></code> list.</p>
<p>There is one minor exception to this rule, namely that CLI-level keyword
arguments (<code class="docutils literal notranslate"><span class="pre">mytask:exclude_hosts=x,y</span></code>) <strong>will</strong> be taken into account when
examining host lists set via <code class="docutils literal notranslate"><span class="pre">&#64;hosts</span></code> or <code class="docutils literal notranslate"><span class="pre">&#64;roles</span></code>. Thus a task function
decorated with <code class="docutils literal notranslate"><span class="pre">&#64;hosts('host1',</span> <span class="pre">'host2')</span></code> executed as <code class="docutils literal notranslate"><span class="pre">fab</span>
<span class="pre">taskname:exclude_hosts=host2</span></code> will only run on <code class="docutils literal notranslate"><span class="pre">host1</span></code>.</p>
<p>As with the host list merging, this functionality is currently limited (partly
to keep the implementation simple) and may be expanded in future releases.</p>
</div>
</div>
</div>
<div class="section" id="intelligently-executing-tasks-with-execute">
<span id="execute"></span><h2>Intelligently executing tasks with <code class="docutils literal notranslate"><span class="pre">execute</span></code><a class="headerlink" href="#intelligently-executing-tasks-with-execute" title="Permalink to this headline">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.3.</span></p>
</div>
<p>Most of the information here involves “top level” tasks executed via <a class="reference internal" href="fab.html"><span class="doc">fab</span></a>, such as the first example where we called <code class="docutils literal notranslate"><span class="pre">fab</span> <span class="pre">taskA</span> <span class="pre">taskB</span></code>.
However, it’s often convenient to wrap up multi-task invocations like this into
their own, “meta” tasks.</p>
<p>Prior to Fabric 1.3, this had to be done by hand, as outlined in
<a class="reference internal" href="library.html"><span class="doc">Library Use</span></a>. Fabric’s design eschews magical behavior, so simply
<em>calling</em> a task function does <strong>not</strong> take into account decorators such as
<a class="reference internal" href="../api/core/decorators.html#fabric.decorators.roles" title="fabric.decorators.roles"><code class="xref py py-obj docutils literal notranslate"><span class="pre">roles</span></code></a>.</p>
<p>New in Fabric 1.3 is the <a class="reference internal" href="../api/core/tasks.html#fabric.tasks.execute" title="fabric.tasks.execute"><code class="xref py py-obj docutils literal notranslate"><span class="pre">execute</span></code></a> helper function, which takes a
task object or name as its first argument. Using it is effectively the same as
calling the given task from the command line: all the rules given above in
<a class="reference internal" href="#host-lists"><span class="std std-ref">How host lists are constructed</span></a> apply. (The <code class="docutils literal notranslate"><span class="pre">hosts</span></code> and <code class="docutils literal notranslate"><span class="pre">roles</span></code> keyword arguments to
<a class="reference internal" href="../api/core/tasks.html#fabric.tasks.execute" title="fabric.tasks.execute"><code class="xref py py-obj docutils literal notranslate"><span class="pre">execute</span></code></a> are analogous to <a class="reference internal" href="#hosts-per-task-cli"><span class="std std-ref">CLI per-task arguments</span></a>, including how they override all other host/role-setting
methods.)</p>
<p>As an example, here’s a fabfile defining two stand-alone tasks for deploying a
Web application:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">fabric.api</span> <span class="k">import</span> <span class="n">run</span><span class="p">,</span> <span class="n">roles</span>

<span class="n">env</span><span class="o">.</span><span class="n">roledefs</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;db&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;db1&#39;</span><span class="p">,</span> <span class="s1">&#39;db2&#39;</span><span class="p">],</span>
    <span class="s1">&#39;web&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;web1&#39;</span><span class="p">,</span> <span class="s1">&#39;web2&#39;</span><span class="p">,</span> <span class="s1">&#39;web3&#39;</span><span class="p">],</span>
<span class="p">}</span>

<span class="nd">@roles</span><span class="p">(</span><span class="s1">&#39;db&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">migrate</span><span class="p">():</span>
    <span class="c1"># Database stuff here.</span>
    <span class="k">pass</span>

<span class="nd">@roles</span><span class="p">(</span><span class="s1">&#39;web&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">update</span><span class="p">():</span>
    <span class="c1"># Code updates here.</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>In Fabric &lt;=1.2, the only way to ensure that <code class="docutils literal notranslate"><span class="pre">migrate</span></code> runs on the DB servers
and that <code class="docutils literal notranslate"><span class="pre">update</span></code> runs on the Web servers (short of manual
<code class="docutils literal notranslate"><span class="pre">env.host_string</span></code> manipulation) was to call both as top level tasks:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ fab migrate update
</pre></div>
</div>
<p>Fabric &gt;=1.3 can use <a class="reference internal" href="../api/core/tasks.html#fabric.tasks.execute" title="fabric.tasks.execute"><code class="xref py py-obj docutils literal notranslate"><span class="pre">execute</span></code></a> to set up a meta-task. Update the
<code class="docutils literal notranslate"><span class="pre">import</span></code> line like so:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">fabric.api</span> <span class="k">import</span> <span class="n">run</span><span class="p">,</span> <span class="n">roles</span><span class="p">,</span> <span class="n">execute</span>
</pre></div>
</div>
<p>and append this to the bottom of the file:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">deploy</span><span class="p">():</span>
    <span class="n">execute</span><span class="p">(</span><span class="n">migrate</span><span class="p">)</span>
    <span class="n">execute</span><span class="p">(</span><span class="n">update</span><span class="p">)</span>
</pre></div>
</div>
<p>That’s all there is to it; the <a class="reference internal" href="../api/core/decorators.html#fabric.decorators.roles" title="fabric.decorators.roles"><code class="xref py py-obj docutils literal notranslate"><span class="pre">roles</span></code></a> decorators will be honored as expected, resulting in the following execution sequence:</p>
<ul class="simple">
<li><code class="xref py py-obj docutils literal notranslate"><span class="pre">migrate</span></code> on <code class="xref py py-obj docutils literal notranslate"><span class="pre">db1</span></code></li>
<li><code class="xref py py-obj docutils literal notranslate"><span class="pre">migrate</span></code> on <code class="xref py py-obj docutils literal notranslate"><span class="pre">db2</span></code></li>
<li><code class="xref py py-obj docutils literal notranslate"><span class="pre">update</span></code> on <code class="xref py py-obj docutils literal notranslate"><span class="pre">web1</span></code></li>
<li><code class="xref py py-obj docutils literal notranslate"><span class="pre">update</span></code> on <code class="xref py py-obj docutils literal notranslate"><span class="pre">web2</span></code></li>
<li><code class="xref py py-obj docutils literal notranslate"><span class="pre">update</span></code> on <code class="xref py py-obj docutils literal notranslate"><span class="pre">web3</span></code></li>
</ul>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>This technique works because tasks that themselves have no host list (this
includes the global host list settings) only run one time. If used inside a
“regular” task that is going to run on multiple hosts, calls to
<a class="reference internal" href="../api/core/tasks.html#fabric.tasks.execute" title="fabric.tasks.execute"><code class="xref py py-obj docutils literal notranslate"><span class="pre">execute</span></code></a> will also run multiple times, resulting in
multiplicative numbers of subtask calls – be careful!</p>
<p class="last">If you would like your <code class="xref py py-obj docutils literal notranslate"><span class="pre">execute</span></code> calls to only be called once, you
may use the <a class="reference internal" href="../api/core/decorators.html#fabric.decorators.runs_once" title="fabric.decorators.runs_once"><code class="xref py py-obj docutils literal notranslate"><span class="pre">runs_once</span></code></a> decorator.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="../api/core/tasks.html#fabric.tasks.execute" title="fabric.tasks.execute"><code class="xref py py-obj docutils literal notranslate"><span class="pre">execute</span></code></a>, <a class="reference internal" href="../api/core/decorators.html#fabric.decorators.runs_once" title="fabric.decorators.runs_once"><code class="xref py py-obj docutils literal notranslate"><span class="pre">runs_once</span></code></a></p>
</div>
<div class="section" id="leveraging-execute-to-access-multi-host-results">
<span id="leveraging-execute-return-value"></span><h3>Leveraging <code class="docutils literal notranslate"><span class="pre">execute</span></code> to access multi-host results<a class="headerlink" href="#leveraging-execute-to-access-multi-host-results" title="Permalink to this headline">¶</a></h3>
<p>In nontrivial Fabric runs, especially parallel ones, you may want to gather up
a bunch of per-host result values at the end - e.g. to present a summary table,
perform calculations, etc.</p>
<p>It’s not possible to do this in Fabric’s default “naive” mode (one where you
rely on Fabric looping over host lists on your behalf), but with <a class="reference internal" href="../api/core/tasks.html#fabric.tasks.execute" title="fabric.tasks.execute"><code class="xref py py-obj docutils literal notranslate"><span class="pre">execute</span></code></a>
it’s pretty easy. Simply switch from calling the actual work-bearing task, to
calling a “meta” task which takes control of execution with <a class="reference internal" href="../api/core/tasks.html#fabric.tasks.execute" title="fabric.tasks.execute"><code class="xref py py-obj docutils literal notranslate"><span class="pre">execute</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">fabric.api</span> <span class="k">import</span> <span class="n">task</span><span class="p">,</span> <span class="n">execute</span><span class="p">,</span> <span class="n">run</span><span class="p">,</span> <span class="n">runs_once</span>

<span class="nd">@task</span>
<span class="k">def</span> <span class="nf">workhorse</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">run</span><span class="p">(</span><span class="s2">&quot;get my infos&quot;</span><span class="p">)</span>

<span class="nd">@task</span>
<span class="nd">@runs_once</span>
<span class="k">def</span> <span class="nf">go</span><span class="p">():</span>
    <span class="n">results</span> <span class="o">=</span> <span class="n">execute</span><span class="p">(</span><span class="n">workhorse</span><span class="p">)</span>
    <span class="nb">print</span> <span class="n">results</span>
</pre></div>
</div>
<p>In the above, <code class="docutils literal notranslate"><span class="pre">workhorse</span></code> can do any Fabric stuff at all – it’s literally
your old “naive” task – except that it needs to return something useful.</p>
<p><code class="docutils literal notranslate"><span class="pre">go</span></code> is your new entry point (to be invoked as <code class="docutils literal notranslate"><span class="pre">fab</span> <span class="pre">go</span></code>, or whatnot) and
its job is to take the <code class="docutils literal notranslate"><span class="pre">results</span></code> dictionary from the <a class="reference internal" href="../api/core/tasks.html#fabric.tasks.execute" title="fabric.tasks.execute"><code class="xref py py-obj docutils literal notranslate"><span class="pre">execute</span></code></a> call and do
whatever you need with it. Check the API docs for details on the structure of
that return value.</p>
</div>
<div class="section" id="using-execute-with-dynamically-set-host-lists">
<span id="dynamic-hosts"></span><h3>Using <code class="docutils literal notranslate"><span class="pre">execute</span></code> with dynamically-set host lists<a class="headerlink" href="#using-execute-with-dynamically-set-host-lists" title="Permalink to this headline">¶</a></h3>
<p>A common intermediate-to-advanced use case for Fabric is to parameterize lookup
of one’s target host list at runtime (when use of <a class="reference internal" href="#execution-roles"><span class="std std-ref">Roles</span></a> does not
suffice). <code class="docutils literal notranslate"><span class="pre">execute</span></code> can make this extremely simple, like so:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">fabric.api</span> <span class="k">import</span> <span class="n">run</span><span class="p">,</span> <span class="n">execute</span><span class="p">,</span> <span class="n">task</span>

<span class="c1"># For example, code talking to an HTTP API, or a database, or ...</span>
<span class="kn">from</span> <span class="nn">mylib</span> <span class="k">import</span> <span class="n">external_datastore</span>

<span class="c1"># This is the actual algorithm involved. It does not care about host</span>
<span class="c1"># lists at all.</span>
<span class="k">def</span> <span class="nf">do_work</span><span class="p">():</span>
    <span class="n">run</span><span class="p">(</span><span class="s2">&quot;something interesting on a host&quot;</span><span class="p">)</span>

<span class="c1"># This is the user-facing task invoked on the command line.</span>
<span class="nd">@task</span>
<span class="k">def</span> <span class="nf">deploy</span><span class="p">(</span><span class="n">lookup_param</span><span class="p">):</span>
    <span class="c1"># This is the magic you don&#39;t get with @hosts or @roles.</span>
    <span class="c1"># Even lazy-loading roles require you to declare available roles</span>
    <span class="c1"># beforehand. Here, the sky is the limit.</span>
    <span class="n">host_list</span> <span class="o">=</span> <span class="n">external_datastore</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">lookup_param</span><span class="p">)</span>
    <span class="c1"># Put this dynamically generated host list together with the work to be</span>
    <span class="c1"># done.</span>
    <span class="n">execute</span><span class="p">(</span><span class="n">do_work</span><span class="p">,</span> <span class="n">hosts</span><span class="o">=</span><span class="n">host_list</span><span class="p">)</span>
</pre></div>
</div>
<p>For example, if <code class="docutils literal notranslate"><span class="pre">external_datastore</span></code> was a simplistic “look up hosts by tag
in a database” service, and you wanted to run a task on all hosts tagged as
being related to your application stack, you might call the above like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ fab deploy:app
</pre></div>
</div>
<p>But wait! A data migration has gone awry on the DB servers. Let’s fix up our
migration code in our source repo, and deploy just the DB boxes again:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ fab deploy:db
</pre></div>
</div>
<p>This use case looks similar to Fabric’s roles, but has much more potential, and
is by no means limited to a single argument. Define the task however you wish,
query your external data store in whatever way you need – it’s just Python.</p>
<div class="section" id="the-alternate-approach">
<h4>The alternate approach<a class="headerlink" href="#the-alternate-approach" title="Permalink to this headline">¶</a></h4>
<p>Similar to the above, but using <code class="docutils literal notranslate"><span class="pre">fab</span></code>’s ability to call multiple tasks in
succession instead of an explicit <code class="docutils literal notranslate"><span class="pre">execute</span></code> call, is to mutate
<a class="reference internal" href="env.html#hosts"><span class="std std-ref">env.hosts</span></a> in a host-list lookup task and then call <code class="docutils literal notranslate"><span class="pre">do_work</span></code>
in the same session:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">fabric.api</span> <span class="k">import</span> <span class="n">run</span><span class="p">,</span> <span class="n">task</span>

<span class="kn">from</span> <span class="nn">mylib</span> <span class="k">import</span> <span class="n">external_datastore</span>

<span class="c1"># Marked as a publicly visible task, but otherwise unchanged: still just</span>
<span class="c1"># &quot;do the work, let somebody else worry about what hosts to run on&quot;.</span>
<span class="nd">@task</span>
<span class="k">def</span> <span class="nf">do_work</span><span class="p">():</span>
    <span class="n">run</span><span class="p">(</span><span class="s2">&quot;something interesting on a host&quot;</span><span class="p">)</span>

<span class="nd">@task</span>
<span class="k">def</span> <span class="nf">set_hosts</span><span class="p">(</span><span class="n">lookup_param</span><span class="p">):</span>
    <span class="c1"># Update env.hosts instead of calling execute()</span>
    <span class="n">env</span><span class="o">.</span><span class="n">hosts</span> <span class="o">=</span> <span class="n">external_datastore</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">lookup_param</span><span class="p">)</span>
</pre></div>
</div>
<p>Then invoke like so:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ fab set_hosts:app do_work
</pre></div>
</div>
<p>One benefit of this approach over the previous one is that you can replace
<code class="docutils literal notranslate"><span class="pre">do_work</span></code> with any other “workhorse” task:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ fab set_hosts:db snapshot
$ fab set_hosts:cassandra,cluster2 repair_ring
$ fab set_hosts:redis,environ=prod status
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="failure-handling">
<span id="failures"></span><h2>Failure handling<a class="headerlink" href="#failure-handling" title="Permalink to this headline">¶</a></h2>
<p>Once the task list has been constructed, Fabric will start executing them as
outlined in <a class="reference internal" href="#execution-strategy"><span class="std std-ref">Execution strategy</span></a>, until all tasks have been run on the
entirety of their host lists. However, Fabric defaults to a “fail-fast”
behavior pattern: if anything goes wrong, such as a remote program returning a
nonzero return value or your fabfile’s Python code encountering an exception,
execution will halt immediately.</p>
<p>This is typically the desired behavior, but there are many exceptions to the
rule, so Fabric provides <code class="docutils literal notranslate"><span class="pre">env.warn_only</span></code>, a Boolean setting. It defaults to
<code class="docutils literal notranslate"><span class="pre">False</span></code>, meaning an error condition will result in the program aborting
immediately. However, if <code class="docutils literal notranslate"><span class="pre">env.warn_only</span></code> is set to <code class="docutils literal notranslate"><span class="pre">True</span></code> at the time of
failure – with, say, the <a class="reference internal" href="../api/core/context_managers.html#fabric.context_managers.settings" title="fabric.context_managers.settings"><code class="xref py py-obj docutils literal notranslate"><span class="pre">settings</span></code></a> context
manager – Fabric will emit a warning message but continue executing.</p>
<p>To signal a failure error from a Fabric task, use the <a class="reference internal" href="../api/core/utils.html#fabric.utils.abort" title="fabric.utils.abort"><code class="xref py py-obj docutils literal notranslate"><span class="pre">abort</span></code></a>.
<a class="reference internal" href="../api/core/utils.html#fabric.utils.abort" title="fabric.utils.abort"><code class="xref py py-obj docutils literal notranslate"><span class="pre">abort</span></code></a> signals an error as if it had been detected by Fabric and
follows the regular execution model for control flow.</p>
</div>
<div class="section" id="connections">
<span id="id3"></span><h2>Connections<a class="headerlink" href="#connections" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">fab</span></code> itself doesn’t actually make any connections to remote hosts. Instead,
it simply ensures that for each distinct run of a task on one of its hosts, the
env var <code class="docutils literal notranslate"><span class="pre">env.host_string</span></code> is set to the right value. Users wanting to
leverage Fabric as a library may do so manually to achieve similar effects
(though as of Fabric 1.3, using <a class="reference internal" href="../api/core/tasks.html#fabric.tasks.execute" title="fabric.tasks.execute"><code class="xref py py-obj docutils literal notranslate"><span class="pre">execute</span></code></a> is preferred and more
powerful.)</p>
<p><code class="docutils literal notranslate"><span class="pre">env.host_string</span></code> is (as the name implies) the “current” host string, and is
what Fabric uses to determine what connections to make (or re-use) when
network-aware functions are run. Operations like <a class="reference internal" href="../api/core/operations.html#fabric.operations.run" title="fabric.operations.run"><code class="xref py py-obj docutils literal notranslate"><span class="pre">run</span></code></a> or
<a class="reference internal" href="../api/core/operations.html#fabric.operations.put" title="fabric.operations.put"><code class="xref py py-obj docutils literal notranslate"><span class="pre">put</span></code></a> use <code class="docutils literal notranslate"><span class="pre">env.host_string</span></code> as a lookup key in a shared
dictionary which maps host strings to SSH connection objects.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The connections dictionary (currently located at
<code class="docutils literal notranslate"><span class="pre">fabric.state.connections</span></code>) acts as a cache, opting to return previously
created connections if possible in order to save some overhead, and
creating new ones otherwise.</p>
</div>
<div class="section" id="lazy-connections">
<h3>Lazy connections<a class="headerlink" href="#lazy-connections" title="Permalink to this headline">¶</a></h3>
<p>Because connections are driven by the individual operations, Fabric will not
actually make connections until they’re necessary. Take for example this task
which does some local housekeeping prior to interacting with the remote
server:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">fabric.api</span> <span class="k">import</span> <span class="o">*</span>

<span class="nd">@hosts</span><span class="p">(</span><span class="s1">&#39;host1&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">clean_and_upload</span><span class="p">():</span>
    <span class="n">local</span><span class="p">(</span><span class="s1">&#39;find assets/ -name &quot;*.DS_Store&quot; -exec rm &#39;</span><span class="p">{}</span><span class="s1">&#39; \;&#39;</span><span class="p">)</span>
    <span class="n">local</span><span class="p">(</span><span class="s1">&#39;tar czf /tmp/assets.tgz assets/&#39;</span><span class="p">)</span>
    <span class="n">put</span><span class="p">(</span><span class="s1">&#39;/tmp/assets.tgz&#39;</span><span class="p">,</span> <span class="s1">&#39;/tmp/assets.tgz&#39;</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">cd</span><span class="p">(</span><span class="s1">&#39;/var/www/myapp/&#39;</span><span class="p">):</span>
        <span class="n">run</span><span class="p">(</span><span class="s1">&#39;tar xzf /tmp/assets.tgz&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>What happens, connection-wise, is as follows:</p>
<ol class="arabic simple">
<li>The two <a class="reference internal" href="../api/core/operations.html#fabric.operations.local" title="fabric.operations.local"><code class="xref py py-obj docutils literal notranslate"><span class="pre">local</span></code></a> calls will run without making any network
connections whatsoever;</li>
<li><a class="reference internal" href="../api/core/operations.html#fabric.operations.put" title="fabric.operations.put"><code class="xref py py-obj docutils literal notranslate"><span class="pre">put</span></code></a> asks the connection cache for a connection to
<code class="docutils literal notranslate"><span class="pre">host1</span></code>;</li>
<li>The connection cache fails to find an existing connection for that host
string, and so creates a new SSH connection, returning it to
<a class="reference internal" href="../api/core/operations.html#fabric.operations.put" title="fabric.operations.put"><code class="xref py py-obj docutils literal notranslate"><span class="pre">put</span></code></a>;</li>
<li><a class="reference internal" href="../api/core/operations.html#fabric.operations.put" title="fabric.operations.put"><code class="xref py py-obj docutils literal notranslate"><span class="pre">put</span></code></a> uploads the file through that connection;</li>
<li>Finally, the <a class="reference internal" href="../api/core/operations.html#fabric.operations.run" title="fabric.operations.run"><code class="xref py py-obj docutils literal notranslate"><span class="pre">run</span></code></a> call asks the cache for a connection
to that same host string, and is given the existing, cached connection for
its own use.</li>
</ol>
<p>Extrapolating from this, you can also see that tasks which don’t use any
network-borne operations will never actually initiate any connections (though
they will still be run once for each host in their host list, if any.)</p>
</div>
<div class="section" id="closing-connections">
<h3>Closing connections<a class="headerlink" href="#closing-connections" title="Permalink to this headline">¶</a></h3>
<p>Fabric’s connection cache never closes connections itself – it leaves this up
to whatever is using it. The <a class="reference internal" href="fab.html"><span class="doc">fab</span></a> tool does this bookkeeping for
you: it iterates over all open connections and closes them just before it exits
(regardless of whether the tasks failed or not.)</p>
<p>Library users will need to ensure they explicitly close all open connections
before their program exits. This can be accomplished by calling
<a class="reference internal" href="../api/core/network.html#fabric.network.disconnect_all" title="fabric.network.disconnect_all"><code class="xref py py-obj docutils literal notranslate"><span class="pre">disconnect_all</span></code></a> at the end of your script.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><a class="reference internal" href="../api/core/network.html#fabric.network.disconnect_all" title="fabric.network.disconnect_all"><code class="xref py py-obj docutils literal notranslate"><span class="pre">disconnect_all</span></code></a> may be moved to a more public location in
the future; we’re still working on making the library aspects of Fabric
more solidified and organized.</p>
</div>
</div>
<div class="section" id="multiple-connection-attempts-and-skipping-bad-hosts">
<h3>Multiple connection attempts and skipping bad hosts<a class="headerlink" href="#multiple-connection-attempts-and-skipping-bad-hosts" title="Permalink to this headline">¶</a></h3>
<p>As of Fabric 1.4, multiple attempts may be made to connect to remote servers
before aborting with an error: Fabric will try connecting
<a class="reference internal" href="env.html#connection-attempts"><span class="std std-ref">env.connection_attempts</span></a> times before giving up,
with a timeout of <a class="reference internal" href="env.html#timeout"><span class="std std-ref">env.timeout</span></a> seconds each time. (These
currently default to 1 try and 10 seconds, to match previous behavior, but they
may be safely changed to whatever you need.)</p>
<p>Furthermore, even total failure to connect to a server is no longer an absolute
hard stop: set <a class="reference internal" href="env.html#skip-bad-hosts"><span class="std std-ref">env.skip_bad_hosts</span></a> to <code class="docutils literal notranslate"><span class="pre">True</span></code> and in
most situations (typically initial connections) Fabric will simply warn and
continue, instead of aborting.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.4.</span></p>
</div>
</div>
</div>
<div class="section" id="password-management">
<span id="id4"></span><h2>Password management<a class="headerlink" href="#password-management" title="Permalink to this headline">¶</a></h2>
<p>Fabric maintains an in-memory password cache of your login and sudo passwords
in certain situations; this helps avoid tedious re-entry when multiple systems
share the same password <a class="footnote-reference" href="#id6" id="id5">[1]</a>, or if a remote system’s <code class="docutils literal notranslate"><span class="pre">sudo</span></code> configuration
doesn’t do its own caching.</p>
<div class="section" id="pre-filling-the-password-caches">
<h3>Pre-filling the password caches<a class="headerlink" href="#pre-filling-the-password-caches" title="Permalink to this headline">¶</a></h3>
<p>The first layer is a simple default or fallback password value,
<a class="reference internal" href="env.html#password"><span class="std std-ref">env.password</span></a> (which may also be set at the command line via
<a class="reference internal" href="fab.html#cmdoption-p"><code class="xref std std-option docutils literal notranslate"><span class="pre">--password</span></code></a> or <a class="reference internal" href="fab.html#cmdoption-initial-password-prompt"><code class="xref std std-option docutils literal notranslate"><span class="pre">--initial-password-prompt</span></code></a>). This
env var stores a single password which (if non-empty) will be tried in the
event that the host-specific cache (see below) has no entry for the current
<a class="reference internal" href="env.html#host-string"><span class="std std-ref">host string</span></a>.</p>
<p><a class="reference internal" href="env.html#passwords"><span class="std std-ref">env.passwords</span></a> (plural!) serves as a per-user/per-host cache,
storing the most recently entered password for every unique user/host/port
combination (<strong>note</strong> that you must include <strong>all three values</strong> if modifying
the structure by hand - see the above link for details). Due to this cache,
connections to multiple different users and/or hosts in the same session will
only require a single password entry for each. (Previous versions of Fabric
used only the single, default password cache and thus required password
re-entry every time the previously entered password became invalid.)</p>
</div>
<div class="section" id="auto-filling-updating-from-user-input">
<h3>Auto-filling/updating from user input<a class="headerlink" href="#auto-filling-updating-from-user-input" title="Permalink to this headline">¶</a></h3>
<p>Depending on your configuration and the number of hosts your session will
connect to, you may find setting either or both of the above env vars to be
useful. However, Fabric will automatically fill them in as necessary without
any additional configuration.</p>
<p>Specifically, each time a password prompt is presented to the user, the value
entered is used to update both the single default password cache, and the cache
value for the current value of <code class="docutils literal notranslate"><span class="pre">env.host_string</span></code>.</p>
</div>
<div class="section" id="specifying-sudo-only-passwords">
<span id="sudo-passwords"></span><h3>Specifying <code class="docutils literal notranslate"><span class="pre">sudo</span></code>-only passwords<a class="headerlink" href="#specifying-sudo-only-passwords" title="Permalink to this headline">¶</a></h3>
<p>In some situations (such as those involving two-factor authentication, or any
other situation where submitting a password at login time is not desired or
correct) you may want to only cache passwords intended for <code class="docutils literal notranslate"><span class="pre">sudo</span></code>, instead of
reusing the values for both login and <code class="docutils literal notranslate"><span class="pre">sudo</span></code> purposes.</p>
<p>To do this, you may set <a class="reference internal" href="env.html#sudo-password"><span class="std std-ref">env.sudo_password</span></a> or populate
<a class="reference internal" href="env.html#sudo-passwords"><span class="std std-ref">env.sudo_passwords</span></a>, which mirror <code class="docutils literal notranslate"><span class="pre">env.password</span></code> and
<code class="docutils literal notranslate"><span class="pre">env.passwords</span></code> (described above). These values will <strong>only</strong> be used in
responding to <code class="docutils literal notranslate"><span class="pre">sudo</span></code> password prompts, and will never be submitted at
connection time.</p>
<p>There is also an analogue to the <code class="docutils literal notranslate"><span class="pre">--password</span></code> command line flag, named
<a class="reference internal" href="fab.html#cmdoption-sudo-password"><code class="xref std std-option docutils literal notranslate"><span class="pre">--sudo-password</span></code></a>, and like <a class="reference internal" href="fab.html#cmdoption-initial-password-prompt"><code class="xref std std-option docutils literal notranslate"><span class="pre">--initial-password-prompt</span></code></a>,
there exists <a class="reference internal" href="fab.html#cmdoption-initial-sudo-password-prompt"><code class="xref std std-option docutils literal notranslate"><span class="pre">--initial-sudo-password-prompt</span></code></a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">When both types of passwords are filled in (e.g. if <code class="docutils literal notranslate"><span class="pre">env.password</span> <span class="pre">=</span>
<span class="pre">&quot;foo&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">env.sudo_password</span> <span class="pre">=</span> <span class="pre">&quot;bar&quot;</span></code>), the <code class="docutils literal notranslate"><span class="pre">sudo</span></code> specific passwords
will be used.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Due to backwards compatibility concerns, user-entered <code class="docutils literal notranslate"><span class="pre">sudo</span></code> passwords
will still be cached into <code class="docutils literal notranslate"><span class="pre">env.password</span></code>/<code class="docutils literal notranslate"><span class="pre">env.passwords</span></code>;
<code class="docutils literal notranslate"><span class="pre">env.sudo_password</span></code>/<code class="docutils literal notranslate"><span class="pre">env.sudo_passwords</span></code> are purely for noninteractive
use.</p>
</div>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[1]</a></td><td>We highly recommend the use of SSH <a class="reference external" href="http://en.wikipedia.org/wiki/Public_key">key-based access</a> instead of relying on
homogeneous password setups, as it’s significantly more secure.</td></tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="leveraging-native-ssh-config-files">
<span id="ssh-config"></span><h2>Leveraging native SSH config files<a class="headerlink" href="#leveraging-native-ssh-config-files" title="Permalink to this headline">¶</a></h2>
<p>Command-line SSH clients (such as the one provided by <a class="reference external" href="http://openssh.org">OpenSSH</a>) make use of a specific configuration format typically
known as <code class="docutils literal notranslate"><span class="pre">ssh_config</span></code>, and will read from a file in the platform-specific
location <code class="docutils literal notranslate"><span class="pre">$HOME/.ssh/config</span></code> (or an arbitrary path given to
<a class="reference internal" href="fab.html#cmdoption-ssh-config-path"><code class="xref std std-option docutils literal notranslate"><span class="pre">--ssh-config-path</span></code></a>/<a class="reference internal" href="env.html#ssh-config-path"><span class="std std-ref">env.ssh_config_path</span></a>.) This
file allows specification of various SSH options such as default or per-host
usernames, hostname aliases, and toggling other settings (such as whether to
use <a class="reference internal" href="env.html#forward-agent"><span class="std std-ref">agent forwarding</span></a>.)</p>
<p>Fabric’s SSH implementation allows loading a subset of these options from one’s
actual SSH config file, should it exist. This behavior is not enabled by
default (in order to be backwards compatible) but may be turned on by setting
<a class="reference internal" href="env.html#use-ssh-config"><span class="std std-ref">env.use_ssh_config</span></a> to <code class="docutils literal notranslate"><span class="pre">True</span></code> at the top of your
fabfile.</p>
<p>If enabled, the following SSH config directives will be loaded and honored by Fabric:</p>
<ul>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">User</span></code> and <code class="docutils literal notranslate"><span class="pre">Port</span></code> will be used to fill in the appropriate connection
parameters when not otherwise specified, in the following fashion:</p>
<ul class="simple">
<li>Globally specified <code class="docutils literal notranslate"><span class="pre">User</span></code>/<code class="docutils literal notranslate"><span class="pre">Port</span></code> will be used in place of the current
defaults (local username and 22, respectively) if the appropriate env vars
are not set.</li>
<li>However, if <a class="reference internal" href="env.html#user"><span class="std std-ref">env.user</span></a>/<a class="reference internal" href="env.html#port"><span class="std std-ref">env.port</span></a> <em>are</em> set, they
override global <code class="docutils literal notranslate"><span class="pre">User</span></code>/<code class="docutils literal notranslate"><span class="pre">Port</span></code> values.</li>
<li>User/port values in the host string itself (e.g. <code class="docutils literal notranslate"><span class="pre">hostname:222</span></code>) will
override everything, including any <code class="docutils literal notranslate"><span class="pre">ssh_config</span></code> values.</li>
</ul>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">HostName</span></code> can be used to replace the given hostname, just like with
regular <code class="docutils literal notranslate"><span class="pre">ssh</span></code>. So a <code class="docutils literal notranslate"><span class="pre">Host</span> <span class="pre">foo</span></code> entry specifying <code class="docutils literal notranslate"><span class="pre">HostName</span> <span class="pre">example.com</span></code>
will allow you to give Fabric the hostname <code class="docutils literal notranslate"><span class="pre">'foo'</span></code> and have that expanded
into <code class="docutils literal notranslate"><span class="pre">'example.com'</span></code> at connection time.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">IdentityFile</span></code> will extend (not replace) <a class="reference internal" href="env.html#key-filename"><span class="std std-ref">env.key_filename</span></a>.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">ForwardAgent</span></code> will augment <a class="reference internal" href="env.html#forward-agent"><span class="std std-ref">env.forward_agent</span></a> in an
“OR” manner: if either is set to a positive value, agent forwarding will be
enabled.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">ProxyCommand</span></code> will trigger use of a proxy command for host connections,
just as with regular <code class="docutils literal notranslate"><span class="pre">ssh</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If all you want to do is bounce SSH traffic off a gateway, you may find
<a class="reference internal" href="env.html#gateway"><span class="std std-ref">env.gateway</span></a> to be a more efficient connection method
(which will also honor more Fabric-level settings) than the typical <code class="docutils literal notranslate"><span class="pre">ssh</span>
<span class="pre">gatewayhost</span> <span class="pre">nc</span> <span class="pre">%h</span> <span class="pre">%p</span></code> method of using <code class="docutils literal notranslate"><span class="pre">ProxyCommand</span></code> as a gateway.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>If your SSH config file contains <code class="docutils literal notranslate"><span class="pre">ProxyCommand</span></code> directives <em>and</em> you have
set <a class="reference internal" href="env.html#gateway"><span class="std std-ref">env.gateway</span></a> to a non-<code class="docutils literal notranslate"><span class="pre">None</span></code> value, <code class="docutils literal notranslate"><span class="pre">env.gateway</span></code>
will take precedence and the <code class="docutils literal notranslate"><span class="pre">ProxyCommand</span></code> will be ignored.</p>
<p class="last">If one has a pre-created SSH config file, rationale states it will be
easier for you to modify <code class="docutils literal notranslate"><span class="pre">env.gateway</span></code> (e.g. via
<a class="reference internal" href="../api/core/context_managers.html#fabric.context_managers.settings" title="fabric.context_managers.settings"><code class="xref py py-obj docutils literal notranslate"><span class="pre">settings</span></code></a>) than to work around your conf file’s
contents entirely.</p>
</div>
</li>
</ul>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../index.html">
    <img class="logo" src="../_static/logo.png" alt="Logo"/>
    
    <h1 class="logo logo-name">fab-classic</h1>
    
  </a>
</p>



<p class="blurb">Pythonic remote execution</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=ploxiln&repo=fab-classic&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





    

<p>
<a class="badge" href="https://travis-ci.org/ploxiln/fab-classic">
    <img
        alt="https://secure.travis-ci.org/ploxiln/fab-classic.svg?branch=master"
        src="https://secure.travis-ci.org/ploxiln/fab-classic.svg?branch=master"
    />
</a>
</p>


<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../installing.html">Installing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial.html">Overview and Tutorial</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="env.html">The environment dictionary, <code class="docutils literal notranslate"><span class="pre">env</span></code></a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Execution model</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#execution-strategy">Execution strategy</a></li>
<li class="toctree-l2"><a class="reference internal" href="#defining-tasks">Defining tasks</a></li>
<li class="toctree-l2"><a class="reference internal" href="#defining-host-lists">Defining host lists</a></li>
<li class="toctree-l2"><a class="reference internal" href="#intelligently-executing-tasks-with-execute">Intelligently executing tasks with <code class="docutils literal notranslate"><span class="pre">execute</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#failure-handling">Failure handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="#connections">Connections</a></li>
<li class="toctree-l2"><a class="reference internal" href="#password-management">Password management</a></li>
<li class="toctree-l2"><a class="reference internal" href="#leveraging-native-ssh-config-files">Leveraging native SSH config files</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="fab.html"><code class="docutils literal notranslate"><span class="pre">fab</span></code> options and arguments</a></li>
<li class="toctree-l1"><a class="reference internal" href="fabfiles.html">Fabfile construction and use</a></li>
<li class="toctree-l1"><a class="reference internal" href="interactivity.html">Interaction with remote programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="library.html">Library Use</a></li>
<li class="toctree-l1"><a class="reference internal" href="output_controls.html">Managing output</a></li>
<li class="toctree-l1"><a class="reference internal" href="parallel.html">Parallel execution</a></li>
<li class="toctree-l1"><a class="reference internal" href="ssh.html">SSH behavior</a></li>
<li class="toctree-l1"><a class="reference internal" href="tasks.html">Defining tasks</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../troubleshooting.html">Troubleshooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq.html">Frequently Asked Questions (FAQ)</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../api/core/colors.html">Color output functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/core/context_managers.html">Context Managers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/core/decorators.html">Decorators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/core/docs.html">Documentation helpers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/core/network.html">Network</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/core/operations.html">Operations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/core/tasks.html">Tasks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/core/utils.html">Utils</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../api/contrib/console.html">Console Output Utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/contrib/django.html">Django Integration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/contrib/files.html">File and Directory Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/contrib/project.html">Project Tools</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../running_tests.html">Running Fabric’s Tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="../old_changelog.html">Old Changelog</a></li>
</ul>


<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;Fabric authors.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.9</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/usage/execution.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>